// Функція - це підпрограма, незалежна частина коду, призначена для багаторазового виконання конкретної задачі з різними початковими значеннями. Функції дозволяють структурувати великі програми, зменшують повторення та ізолюють код.

// Функцію можна уявити у вигляді чорного ящика: вона отримує щось на вході (дані), і повертає щось на виході (результат виконання коду всередині неї).

// *** Оголошення функції

// // 1. Оголошення функції multiply
// function multiply() {
//   // Тіло функції
//   console.log("Це лог на момент виклику функції multiply");
// }

// // 2. Виклики функції multiply
// multiply(); // 'Це лог на момент виклику функції multiply'
// multiply(); // 'Це лог на момент виклику функції multiply'
// multiply(); // 'Це лог на момент виклику функції multiply'

// *** Параметри та аргументи

// В круглих дужках після імені функції зазначаються `параметри` - перелік даних, які функція очікує на момент виклику.

// // *Оголошення параметрів x, y, z
// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// Параметри - це локальні змінні, доступні тільки у тілі функції.\

// На момент виклику функції, в круглих дужках можна передати `аргументи` - значення для оголошених параметрів функції.

// // 1. Оголошення параметрів x, y, z
// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// // 2. Передача аргументів
// multiply(2, 3, 5); // Результат множення дорівнює 30
// multiply(4, 8, 12); // Результат множення дорівнює 384
// multiply(17, 6, 25); // Результат множення дорівнює 2550

// *** Повернення значення

// Оператор `return` використовується для передачі значення з тіла функції у зовнішній код.

// function multiply(x, y, z) {
//   console.log("Код до return виконується звичайним чином");

//   // Повертаємо результат виразу множення
//   return x * y * z;

//   console.log("Цей лог ніколи не виконається, він стоїть після return");
// }

// // Результат роботи функції можна зберегти у змінну
// let result = multiply(2, 3, 5);
// console.log(result); // 30

// result = multiply(4, 8, 12);
// console.log(result); // 384

// result = multiply(17, 6, 25);
// console.log(result); // 2550

// * Оператор return без явно вказаного значення повертає спеціальне значення undefined. За відсутності return в тілі функції, вона все одно поверне undefined.

// *** Порядок виконання коду

// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// console.log("Лог до виклику функції multiply");
// multiply(2, 3, 5); // Результат множення дорівнює 30
// console.log("Лог після виклику функції multiply");

// // Послідовність логів в консолі
// // "Лог до виклику функції multiply"
// // "Результат множення дорівнює 30"
// // "Лог після виклику функції multiply"

// *** Параметри за замовчуванням

// function count(countFrom = 0, countTo = 10, step = 1) {
//   console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);

//   for (let i = countFrom; i <= countTo; i += step) {
//     console.log(i);
//   }
// }

// count(1, 5); // countFrom = 1, countTo = 5, step = 1
// count(2); // countFrom = 2, countTo = 10, step = 1
// count(); // countFrom = 0, countTo = 10, step = 1

// *** Псевдомасив 'arguments'

// Доступ до списку всіх аргументів можна отримати за допомогою спеціальної змінної 'arguments', яка доступна тільки всередині функції і зберігає всі аргументи у якості псевдомасиву.

// Псевдомасив - колекція з властивістю 'length' і можливістю звернутися до елементу за індексом, але відсутністю більшості методів для роботи з масивом.

// Розглянемо приклад використання 'arguments' у функції, яка множить будь-яку кількість аргументів:

// function multiply() {
//   let total = 1;

//   for (const argument of arguments) {
//     total *= argument;
//   }

//   return total;
// }

// console.log(multiply(1, 2, 3)); //  6
// console.log(multiply(1, 2, 3, 4)); //  24
// console.log(multiply(1, 2, 3, 4, 5)); //  120

// *** Перетворення псевдомасиву

// Зазвичай псевдомасив необхідно перетворити у повноцінний масив, оскільки у псевдомасиву відсутні методи масиву, наприклад 'slice()' або 'includes()'. На практиці застосовують декілька основних способів.

// Використовуючи метод 'Array.from()', який створить масив із псевдомасиву.

// function fn() {
//   // Змінна args буде містити повноцінний масив
//   const args = Array.from(arguments);
// }
// Використовуючи операцію ... (rest), вона дозволяє зібрати будь-яку кількість елементів, у нашому випадку аргументів, в масив, і зберегти його в змінну. Збираємо всі аргументи, використовуючи операцію rest безпосередньо в підписі функції.

// function fn(...args) {
//   // Змінна args буде містити повноцінний масив
// }

// *** Патерн «Раннє повернення»

// Оператор 'if...else' - це основний спосіб створення розгалужень. Проте, складні вкладені розгалуження роблять код заплутаним для розуміння.

// function withdraw(amount, balance) {
//   if (amount === 0) {
//     console.log("Для проведення операції введіть суму більшу за нуль");
//   } else if (amount > balance) {
//     console.log("Недостатньо коштів на рахунку");
//   } else {
//     console.log("Операція зняття коштів проведена успішно");
//   }
// }

// withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
// withdraw(500, 300); // "Недостатньо коштів на рахунку"
// withdraw(100, 300); // "Операція зняття коштів проведена успішно"

// Патерн «Раннє повернення» - це спосіб використовувати можливість дострокового повернення з функції за допомогою оператора return.

// function withdraw(amount, balance) {
//   // Якщо умова виконується, викликається console.log
//   // і вихід із функції. Код після тіла if не виконається.
//   if (amount === 0) {
//     console.log("Для проведення операції введіть суму більшу за нуль");
//     return;
//   }

//   // Якщо умова першого if не виконалась, його тіло пропускається
//   // та інтерпретатор доходе до другого if.
//   // Якщо умова виконується, викликається console.log і вихід із функції.
//   // Код, що знаходиться після тіла if, не виконається.
//   if (amount > balance) {
//     console.log("Недостатньо коштів на рахунку");
//     return;
//   }

//   // Якщо жоден із попередніх if не виконався,
//   // інтерпретатор доходить до цього коду і виконує його.
//   console.log("Операція зняття коштів проведена");
// }

// withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
// withdraw(500, 300); // "Недостатньо коштів на рахунку"
// withdraw(100, 300); // "Операція зняття коштів проведена"

// *** Функціональний вираз

// Функціональний вираз (function expression) - звичайне оголошення змінної, значенням якої буде функція. Альтернативний спосіб оголошення функції.

// // Оголошення функції (function declaration)
// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// // Функціональний вираз (function expression)
// const multiply = function (x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// };

// Різниця в тому, що функціональний вираз не можна викликати до місця його створення, тільки після нього, тому що це буквально оголошення const змінної.

// // ❌ Помилка! Не працює виклик до оголошення
// multiply(1, 2, 3);

// const multiply = function (x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// };

// // ✅ Працює виклик після оголошення
// multiply(4, 5, 6);
// A оголошення функції можна викликати до місця її створення в коді.

// // ✅ Працює виклик до оголошення
// multiply(1, 2, 3);

// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// // ✅ Працює виклик після оголошення
// multiply(4, 5, 6);

// ! Область видимості

// Область видимості (scope) - механізм, який визначає доступність змінних у коді, що виконується.

// Ланцюжок областей видимості (scope chain) - області видимості утворюють ієрархію, за якою дочірні області мають доступ до змінних з батьківських областей, але не навпаки.

// *** Глобальна область видимості

// Змінні, оголошені на найвищому рівні, тобто за межами будь-яких конструкцій на зразок 'if', 'while', 'for' і 'функцій', знаходяться в глобальній області видимості і доступні всюди після їх оголошення.

// const globalValue = 10;

// console.log(globalValue); // 10

// function foo() {
//   console.log(globalValue); // 10
// }

// for (let i = 0; i < 5; i++) {
//   console.log(globalValue); // 10

//   if (i === 2) {
//     console.log(globalValue); // 10
//   }
// }

// *** Блокова область видимості

// Змінні, оголошені всередині інструкцій 'if', for, функцій та інших блоків коду, взятих у фігурні дужки {}, знаходяться в блоковій області видимості і доступні тільки всередині цього блоку коду або у блоках, вкладених в нього.

// function foo() {
//   const a = 20;
//   console.log(a); // 20

//   for (let i = 0; i < 5; i++) {
//     console.log(a); // 20

//     if (i === 2) {
//       console.log(a); // 20
//     }
//   }
// }

// // ❌ Помилка! Змінна a - недоступна у глобальній області видимості
// console.log(a);

// for (let i = 0; i < 3; i++) {
//   // ❌ Помилка! Змінна a - недоступна в цій області видимості
//   console.log(a);
// }

// Це можна уявити у вигляді будинку з кімнатами. Будинок знаходиться в глобальній області видимості. Кожна функція і блок створюють нову кімнату, вкладену всередину будинку. Змінні, оголошені всередині цих кімнат, доступні тільки тоді, коли ви знаходитесь всередині цієї кімнати. За межами кімнати ці змінні - недоступні.

// for (let i = 0; i < 5; i++) {
//   const a = 20;
//   console.log(a); // 20

//   if (i === 2) {
//     const b = 30;
//     console.log(a); // 20
//     console.log(b); // 30
//   }

//   if (i === 3) {
//     console.log(a); // 20

//     // ❌ Помилка! Змінна b - недоступна в цій області видимості
//     console.log(b);
//   }
// }

//

// ! Стек викликів

// На момент виклику функції, всередині її тіла можуть викликатися інші функції, а в них - інші тощо. JavaScript - однопотокова мова, тобто за одну одиницю часу може виконуватись лише одна інструкція. Це означає, що викликані функції, які не завершили своє виконання, повинні чекати виконання функцій, викликаних всередині них, для того, щоб продовжити свою роботу.

// function fnA() {
//   console.log("Лог всередині функції fnA до виклику fnB");
//   fnB();
//   console.log("Лог всередині функції fnA після виклику fnB");
// }

// function fnB() {
//   console.log("Лог всередині функції fnB");
// }

// console.log("Лог до виклику fnA");
// fnA();
// console.log("Лог після виклику fnA");

// // "Лог до виклику fnA"
// // "Лог всередині функції fnA до виклику fnB"
// // "Лог всередині функції fnB"
// // "Лог всередині функції fnA після виклику fnB"
// // "Лог після виклику fnA"
// Потрібен механізм зберігання списку функцій, які були викликані, але ще не завершили своє виконання, і механізм керування порядком виконання цих функцій - саме за це відповідає стек викликів (call stack).

// *** Стек

// Стек - структура даних, яка працює за принципом 'LIFO' (Last-In-First-Out), тобто останнім прийшов - першим пішов. Останнє, що додається у стек, буде видалено з нього першим, - тому можна додати або видалити елементи тільки з верхівки стека.

// *** Стек викликів

// function bar() {
//   console.log("bar");
// }

// function baz() {
//   console.log("baz");
// }

// function foo() {
//   console.log("foo");
//   bar();
//   baz();
// }

// foo();
// Коли виконується цей код, спочатку викликається foo(), потім всередині foo() викликається bar(), а потім - baz(). Виклики console.log() так само враховуються, адже - це функція. На ілюстрації нижче, для прикладу, покроково зображений стек викликів.

// ЗАПИТАННЯ???
// function getCommonElements(array1, array2) {
//   // Change code below this line
//   let array3 = [];
//   for (const number of array1) {
//     if (array2.includes(number)) {
//       array3.push(number);
//     }
//   }
//   return array3;
//   // Change code above this line
// }

// ЗАПИТАННЯ???

// function calculateTotalPrice(order) {
//   let total = 0;
//   // Change code below this line

//   for (let i = 0; i < order.length; i += 1) {
//     total += order[i];
//   }

//   // Change code above this line
//   return total;
// }

// new question 27/2

// function filterArray(numbers, value) {
//   // Change code below this line
//   let filteredNumbers = [];
//   for (const number of numbers) {
//     // console.log(number);
//     if (number > value) {
//       filteredNumbers.push(number);
//     }
//   }

//   // return filteredNumbers;
//   console.log(filteredNumbers);
//   // Change code above this line
// }

// function filterqArray(numbers, value) {
//   // Change code below this line
//   const filteredNumbers = [];

//   for (let i = 0; i < numbers.length; i += 1) {
//     // console.log(i);
//     const number = numbers[i];

//     if (number > value) {
//       filteredNumbers.push(number);
//     }
//   }

//   return filteredNumbers;
//   console.log(filteredNumbers);
//   // Change code above this line
// }
// filterArray([2, 3, 4, 5, 13], 3);
// filterqArray([12, 24, 8, 41, 76], 38);

// question 30/2

// const start = 6;
// const end = 27;
// let number;

// for (let i = start; i < end; i += 1) {
//   if (i % 5 === 0) {
//     number = i;
//     break;
//   }
// }

// console.log(number);

// === Example 1 - Базовые операции с массивом ===
// Создайте массив genres с элементами «Jazz» и «Blues».
// Добавьте «Рок-н-ролл» в конец.
// Выведите в консоль первый элемент массива.
// Выведите в консоль последний элемент массива. Код должен работать для массива произвольной длины.
// Удалите первый элемент и выведите его в консоль.
// Вставьте «Country» и «Reggy» в начало массива.
// const genres = ["Jazz", "Blues"];
// genres.push("Рок-н-ролл");
// console.log(genres);

// console.log(genres[0]);
// console.log(genres[genres.length - 1]);
// console.log(genres.shift());
// console.log(genres);

// genres.unshift("Country", "Reggy");
// console.log(genres);

// === Example 2 - Массивы и строки ===
// Напиши скрипт для вычисления площади прямоугольника со сторонами, значения которых хранятся в переменной values в виде строки. Значения гарантированно разделены пробелом.

// const values = "8 11";
// const numbers = values.split(" ");
// const a = Number(numbers[0]);
// const b = Number(numbers[1]);
// const s = a * b;

// console.log(numbers);
// console.log(a, b);
// console.log("s:", s);

// === Example 3 - Перебор массива ===
// Напиши скрипт для перебора массива fruits циклом for. Для каждого элемента массива выведи в консоль строку в формате номер_элемента: значение_элемента. Нумерация элементов должна начинаться с 1.

// const fruits = ["🍎", "🍇", "🍑", "🍌", "🍋"];
// for (let i = 0; i < fruits.length; i += 1) {
//   console.log(`${i + 1}: ${fruits[i]}`);
// }

// === Example 4 - Массивы и циклы ===
// Напиши скрипт который выводит в консоль имя и телефонный номер пользователя. В переменных names и phones хранятся строки имен и телефонных номеров, разделенные запятыми. Порядковый номер имен и телефонов в строках указывают на соответствие. Количество имен и телефонов гарантированно одинаковое.

// const names = "Jacob,William,Solomon,Artemis";
// const phones = "89001234567,89001112233,890055566377,890055566300";

// const namesArray = names.split(",");
// const phonesArray = phones.split(",");

// for (let i = 0; i < namesArray.length; i += 1) {
//   console.log(namesArray[i], phonesArray[i]);
// }

// === Example 5 - Массивы и строки ===
// Напиши скрипт который выводит в консоль все слова строки кроме первого и последнего. Результирующая строка не должна начинаться или заканчиваться пробельным символом. Скрипт должен работать для любой строки.

// const string = "Welcome to the future";
// const strArr = string.split(" ");
// strArr.shift();
// strArr.pop();

// console.log(strArr.join(" "));
